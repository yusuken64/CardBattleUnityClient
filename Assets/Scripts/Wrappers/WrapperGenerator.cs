using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

public static class WrapperGenerator
{
    private static readonly List<Type> Interfaces = new()
    {
        typeof(CardBattleEngine.ITriggerCondition),
        typeof(CardBattleEngine.IGameAction),
        typeof(CardBattleEngine.IAffectedEntitySelector),
        typeof(CardBattleEngine.ITargetOperation)
    };

    [MenuItem("Data/Wrappers/GenerateWrappers")]
    public static void GenerateWrappers()
    {
        // Show confirmation dialog
        bool proceed = EditorUtility.DisplayDialog(
            "Generate Wrappers",
            "This will generate wrapper classes for all target interfaces. Continue?",
            "Yes",
            "No"
        );

        if (!proceed)
        {
            Debug.Log("Wrapper generation canceled.");
            return;
        }

        foreach (var interfaceType in Interfaces)
        {
            Debug.Log($"Generating wrappers for interface: {interfaceType.FullName}");
            GenerateWrappersForInterface(interfaceType);
        }

        AssetDatabase.Refresh();
        Debug.Log("All wrappers generated!");
    }

    [MenuItem("Data/Wrappers/ClearGeneratedWrappers")]
    public static void ClearGeneratedWrappers()
    {
        bool confirm = EditorUtility.DisplayDialog(
            "Clear Generated Wrappers",
            "This will delete all wrapper classes generated by the WrapperGenerator. Continue?",
            "Yes",
            "No"
        );

        if (!confirm)
            return;

        foreach (var interfaceType in Interfaces)
        {
            // Look up the interface .cs file
            string interfacePath = AssetDatabase.FindAssets(interfaceType.Name + " t:Script")
                .Select(guid => AssetDatabase.GUIDToAssetPath(guid))
                .Select(Path.GetDirectoryName)
                .FirstOrDefault();

            if (interfacePath == null)
                interfacePath = "Assets";

            // Each interface folder
            string targetFolder = Path.Combine(interfacePath, interfaceType.Name);
            if (!Directory.Exists(targetFolder))
                continue;

            // Delete all *Wrapper.cs files
            var files = Directory.GetFiles(targetFolder, "*Wrapper.cs", SearchOption.TopDirectoryOnly);
            foreach (var file in files)
            {
                File.Delete(file);
                Debug.Log("Deleted wrapper: " + file);
            }
        }

        AssetDatabase.Refresh();
        Debug.Log("All generated wrappers cleared.");
    }

    private static void GenerateWrappersForInterface(Type interfaceType)
    {
        var concreteTypes = AppDomain.CurrentDomain.GetAssemblies()
            .SelectMany(a => a.GetTypes())
            .Where(t => interfaceType.IsAssignableFrom(t) &&
                        !t.IsInterface &&
                        !t.IsAbstract &&
                        t.IsPublic)
            .ToArray();

        if (concreteTypes.Length == 0)
        {
            Debug.LogWarning("No implementations for " + interfaceType.FullName);
            return;
        }

        // Look up the interface .cs file
        string interfacePath = AssetDatabase.FindAssets(interfaceType.Name + " t:Script")
            .Select(guid => AssetDatabase.GUIDToAssetPath(guid))
            .Select(Path.GetDirectoryName)
            .FirstOrDefault();

        if (interfacePath == null)
            interfacePath = "Assets";

        // Each interface gets its own folder
        string targetFolder = Path.Combine(interfacePath, interfaceType.Name);
        if (!Directory.Exists(targetFolder))
            Directory.CreateDirectory(targetFolder);

        foreach (var type in concreteTypes)
        {
            string wrapperName = type.Name + "Wrapper";
            string filePath = Path.Combine(targetFolder, wrapperName + ".cs");

            string code = GenerateWrapperCode(type, wrapperName, interfaceType);
            File.WriteAllText(filePath, code);

            Debug.Log("Generated wrapper: " + filePath);
        }
    }

    private static string GenerateWrapperCode(Type concreteType, string wrapperName, Type interfaceType)
    {
        string baseClass = $"{interfaceType.Name}WrapperBase";

        var props = concreteType.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => p.CanRead && p.CanWrite)
            .ToArray();

        string propertyLines = string.Join("\n",
            props.Select(p => GenerateFieldForProperty(p)));

        string assignments = string.Join("\n",
            props.Select(p => GenerateAssignmentLine(p))
                .Select(line => "        " + line));

        return $@"using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using {interfaceType.Namespace};

[Serializable]
public class {wrapperName} : {baseClass}
{{
{propertyLines}

    public override {interfaceType.FullName} Create()
    {{
        var instance = new {concreteType.FullName}();
{assignments}
        return instance;
    }}
}}";
    }

    private static string GenerateAssignmentLine(PropertyInfo p)
    {
        string propName = p.Name;
        var propType = p.PropertyType;

        // List<WrapperBase>
        if (IsWrapperList(p))
        {
            return $"instance.{propName} = this.{propName}?.Select(x => x.Create()).ToList();";
        }

        // single WrapperBase
        if (IsWrapperType(propType))
        {
            return $"instance.{propName} = this.{propName}?.Create();";
        }

        // normal field
        return $"instance.{propName} = this.{propName};";
    }

    private static string GetCSharpTypeName(Type type)
    {
        // Nullable<T> → T?
        if (Nullable.GetUnderlyingType(type) is Type underlying)
            return GetCSharpTypeName(underlying) + "?";

        // Generic Types
        if (type.IsGenericType)
        {
            string fullName = type.GetGenericTypeDefinition().FullName;

            // Strip the `1, `2, etc.
            int tickIndex = fullName.IndexOf('`');
            if (tickIndex >= 0)
                fullName = fullName.Substring(0, tickIndex);

            string args = string.Join(", ", type.GetGenericArguments().Select(GetCSharpTypeName));

            return $"{fullName}<{args}>";
        }

        // Array types
        if (type.IsArray)
        {
            return GetCSharpTypeName(type.GetElementType()) + "[]";
        }

        // Fallback: full name (includes namespace)
        return type.FullName;
    }

    private static string GenerateFieldForProperty(PropertyInfo p)
    {
        var type = p.PropertyType;

        bool isList = type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>);

        if (isList)
        {
            var innerType = type.GetGenericArguments()[0];

            // Replace interface with wrapper base type
            if (innerType.IsInterface)
            {
                string wrapperTypeName = innerType.Name + "WrapperBase";

                return
    $@"    [SerializeReference]
    public List<{wrapperTypeName}> {p.Name};";
            }

            // fallback: normal list
            return $"    public {GetCSharpTypeName(type)} {p.Name};";
        }

        // handle arrays of interface types
        if (type.IsArray && type.GetElementType().IsInterface)
        {
            string wrapperTypeName = type.GetElementType().Name + "WrapperBase";
            return
    $@"    [SerializeReference]
    public {wrapperTypeName}[] {p.Name};";
        }

        // normal field
        return $"    public {GetCSharpTypeName(type)} {p.Name};";
    }

    private static bool IsWrapperType(Type type)
    {
        return type.IsInterface && type.Name.EndsWith("WrapperBase");
    }

    private static bool IsWrapperList(PropertyInfo p)
    {
        var t = p.PropertyType;
        return t.IsGenericType &&
               t.GetGenericTypeDefinition() == typeof(List<>) &&
               t.GetGenericArguments()[0].IsInterface;
    }
}
